```rust
use bevy::prelude::*;
use bevy::window::{WindowResized, WindowMode, PrimaryWindow, MonitorSelection};

// 打字机组件
#[derive(Component)]
pub struct TypewriterEffect {
    pub full_text: String,
    pub current_index: usize,
    pub timer: Timer,
    pub finished: bool,
}

impl TypewriterEffect {
    pub fn new(text: String, chars_per_second: f32) -> Self {
        Self {
            full_text: text,
            current_index: 0,
            timer: Timer::from_seconds(1.0 / chars_per_second, TimerMode::Repeating),
            finished: false,
        }
    }
}

// 增强的窗口显示模式枚举
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum WindowDisplayMode {
    Normal,      // < 1280×720
    HD,          // 1280×720 - 1919×1079
    FHD,         // 1920×1080 - 2559×1439
    QHD,         // 2560×1440 - 3839×2159
    UHD,         // 3840×2160+
    Ultrawide,   // 21:9 比例
    Maximized,   // 最大化窗口 (非全屏但很大)
}

impl WindowDisplayMode {
    fn from_window_size_and_mode(window_size: Vec2, window_mode: WindowMode) -> Self {
        let (width, height) = (window_size.x as u32, window_size.y as u32);
        let aspect_ratio = window_size.x / window_size.y;
        
        // 首先检查是否是超宽屏 (21:9 比例)
        if (aspect_ratio - 21.0/9.0).abs() < 0.15 {
            return WindowDisplayMode::Ultrawide;
        }
        
        // 检查是否是全屏模式 - 修复这里的匹配模式
        let is_fullscreen = matches!(window_mode, 
            WindowMode::Fullscreen(..) | WindowMode::BorderlessFullscreen(..)
        );
        
        // 如果不是全屏，但窗口很大，可能是最大化
        if !is_fullscreen && width > 1600 && height > 900 && 
           !Self::is_standard_resolution(width, height) {
            return WindowDisplayMode::Maximized;
        }
        
        // 按分辨率分类
        match (width, height) {
            (0..=1279, 0..=719) => WindowDisplayMode::Normal,
            (1280..=1919, 720..=1079) => WindowDisplayMode::HD,
            (1920..=2559, 1080..=1439) => WindowDisplayMode::FHD,
            (2560..=3839, 1440..=2159) => WindowDisplayMode::QHD,
            (3840.., 2160..) => WindowDisplayMode::UHD,
            _ => {
                // 其他情况，根据大小判断
                if width >= 1920 && height >= 1080 {
                    WindowDisplayMode::FHD
                } else if width >= 1280 && height >= 720 {
                    WindowDisplayMode::HD
                } else {
                    WindowDisplayMode::Normal
                }
            }
        }
    }
    
    fn is_standard_resolution(width: u32, height: u32) -> bool {
        matches!((width, height), 
            (1280, 720) | (1366, 768) | (1600, 900) |
            (1920, 1080) | (2560, 1440) | (3840, 2160) |
            (3440, 1440) | (2560, 1080) // 超宽屏
        )
    }
}

// 自定义范围结构
#[derive(Clone)]
struct CustomRange {
    min_width: f32,
    max_width: f32,
    min_height: f32,
    max_height: f32,
    style: Node,
    priority: u32,
    name: String, // 用于调试
}

impl CustomRange {
    fn new(
        min_width: f32, max_width: f32,
        min_height: f32, max_height: f32,
        style: Node, priority: u32,
        name: &str
    ) -> Self {
        Self {
            min_width,
            max_width,
            min_height,
            max_height,
            style,
            priority,
            name: name.to_string(),
        }
    }

    fn matches(&self, window_size: Vec2) -> bool {
        window_size.x >= self.min_width
            && window_size.x <= self.max_width
            && window_size.y >= self.min_height
            && window_size.y <= self.max_height
    }
}

// 增强的响应式图片节点组件
#[derive(Component)]
struct ResponsiveImageNode {
    custom_ranges: Vec<CustomRange>,
    fallback_style: Node, // 默认样式
    element_name: String, // 元素名称，用于调试
}

impl ResponsiveImageNode {
    fn new(element_name: &str, fallback_style: Node) -> Self {
        Self {
            custom_ranges: Vec::new(),
            fallback_style,
            element_name: element_name.to_string(),
        }
    }

    fn add_custom_range_style(
        mut self,
        min_width: f32, max_width: f32,
        min_height: f32, max_height: f32,
        style: Node, priority: u32,
        name: &str
    ) -> Self {
        self.custom_ranges.push(CustomRange::new(
            min_width, max_width,
            min_height, max_height,
            style, priority, name
        ));
        // 按优先级排序
        self.custom_ranges.sort_by(|a, b| b.priority.cmp(&a.priority));
        self
    }

    fn get_style_for_window_size(&self, window_size: Vec2) -> (&Node, String) {
        for range in &self.custom_ranges {
            if range.matches(window_size) {
                return (&range.style, format!("{} ({})", self.element_name, range.name));
            }
        }
        (&self.fallback_style, format!("{} (fallback)", self.element_name))
    }
}

// 窗口状态资源
#[derive(Resource)]
struct WindowState {
    display_mode: WindowDisplayMode,
    resolution: Vec2,
    window_mode: WindowMode,
}

impl Default for WindowState {
    fn default() -> Self {
        Self {
            display_mode: WindowDisplayMode::Normal,
            resolution: Vec2::new(1280.0, 720.0),
            window_mode: WindowMode::Windowed,
        }
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .insert_resource(ClearColor(Color::BLACK))
        .init_resource::<WindowState>()
        .add_systems(Startup, setup)
        .add_systems(Update, (
            toggle_fullscreen_system,
            detect_window_display_mode,
            update_responsive_image_style,
            update_background_size_on_resize,
            typewriter_system
        ))
        .run();
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    // 创建2D相机
    commands.spawn(Camera2d);
    
    // 背景精灵
    commands.spawn((
        Name::new("spritebox"),
        Transform::from_xyz(0.0, 10.0, 0.0),
        Sprite {
            custom_size: Some(Vec2::new(1920.0, 1070.0)),
            image: asset_server.load("background/bg6.png"),
            ..default()
        },
        Visibility::Visible,
    ));
    
    // 文本框 - 使用 CustomRange 系统
    commands.spawn((
        ImageNode::new(asset_server.load("textbox.png")),
        Node {
            position_type: PositionType::Absolute,
            left: Val::Px(0.0),
            bottom: Val::Px(0.0),
            width: Val::Px(200.0),
            height: Val::Px(150.0),
            ..default()
        },
        ResponsiveImageNode::new(
            "TextBox",
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(200.0),
                height: Val::Px(150.0),
                ..default()
            }
        )
        // Normal (< 1280×720)
        .add_custom_range_style(
            0.0, 1279.0, 0.0, 719.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(800.0),
                height: Val::Px(180.0),
                ..default()
            },
            100, "Normal"
        )
        // HD (1280×720 - 1919×1079)
        .add_custom_range_style(
            1280.0, 1919.0, 720.0, 1079.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1280.0),
                height: Val::Px(220.0),
                ..default()
            },
            200, "HD"
        )
        // FHD (1920×1080 - 2559×1439)
        .add_custom_range_style(
            1920.0, 2559.0, 1080.0, 1439.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1920.0),
                height: Val::Px(280.0),
                ..default()
            },
            300, "FHD"
        )
        // QHD (2560×1440 - 3839×2159)
        .add_custom_range_style(
            2560.0, 3839.0, 1440.0, 2159.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(2560.0),
                height: Val::Px(350.0),
                ..default()
            },
            400, "QHD"
        )
        // UHD (3840×2160+)
        .add_custom_range_style(
            3840.0, f32::INFINITY, 2160.0, f32::INFINITY,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(3840.0),
                height: Val::Px(500.0),
                ..default()
            },
            500, "UHD"
        )
        // Ultrawide (21:9 比例)
        .add_custom_range_style(
            2560.0, 3440.0, 1080.0, 1440.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Percent(100.0),
                height: Val::Px(300.0),
                ..default()
            },
            350, "Ultrawide"
        )
        // Maximized windows
        .add_custom_range_style(
            1600.0, 2559.0, 900.0, 1439.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Percent(90.0),
                height: Val::Px(250.0),
                ..default()
            },
            250, "Maximized"
        ),
    ));

    // 侧边栏 - 使用 CustomRange 系统
    commands.spawn((
        ImageNode::new(asset_server.load("sidebar/456.png")),
        ZIndex(1),
        Node {
            position_type: PositionType::Absolute,
            left: Val::Px(0.0),
            top: Val::Px(0.0),
            width: Val::Px(480.0),
            height: Val::Px(720.0),
            ..default()
        },
        ResponsiveImageNode::new(
            "Sidebar",
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(480.0),
                height: Val::Px(720.0),
                ..default()
            }
        )
        // Normal
        .add_custom_range_style(
            0.0, 1230.0, 0.0, 760.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(200.0),
                top: Val::Px(0.0),
                width: Val::Px(1000.0),
                height: Val::Px(1080.0),
                ..default()
            },
            100, "Normal"
        )
        // HD
        .add_custom_range_style(
            1280.0, 1919.0, 720.0, 1079.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(960.0),
                height: Val::Px(1080.0),
                ..default()
            },
            200, "HD"
        )
        // FHD
        .add_custom_range_style(
            1920.0, 2559.0, 1080.0, 1439.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(960.0),
                height: Val::Px(1080.0),
                ..default()
            },
            300, "FHD"
        )
        // QHD
        .add_custom_range_style(
            2560.0, 3839.0, 1440.0, 2159.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(1280.0),
                height: Val::Px(1440.0),
                ..default()
            },
            400, "QHD"
        )
        // UHD
        .add_custom_range_style(
            3840.0, f32::INFINITY, 2160.0, f32::INFINITY,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(1920.0),
                height: Val::Px(2160.0),
                ..default()
            },
            500, "UHD"
        )
        // Ultrawide
        .add_custom_range_style(
            2560.0, 3440.0, 1080.0, 1440.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(800.0),
                height: Val::Percent(100.0),
                ..default()
            },
            350, "Ultrawide"
        )
        // Maximized
        .add_custom_range_style(
            1600.0, 2559.0, 900.0, 1439.0,
            Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(810.0),
                height: Val::Percent(100.0),
                ..default()
            },
            250, "Maximized"
        ),
    ));
    
    // 添加提示文本
    commands.spawn((
        Text::new("你好，秋月寒"),
        TextFont {
            font: asset_server.load("two.ttf"),
            font_size: 27.0,
            ..default()
        },
        Node {
            position_type: PositionType::Absolute,
            left: Val::Px(590.0),
            bottom: Val::Px(220.0),
            margin: UiRect::all(Val::Px(1.0)),
            ..default()
        },
        ZIndex(2),
        TextColor(Color::srgb_u8(0xb6, 0xf6, 0xfe)),
        Transform::from_xyz(409.0, 200.0, 0.0),
        TypewriterEffect::new("你好，秋月寒".to_string(), 15.0),
    ));
}

fn toggle_fullscreen_system(
    mut windows: Query<&mut Window, With<PrimaryWindow>>,
    keys: Res<ButtonInput<KeyCode>>,
) {
    if keys.just_pressed(KeyCode::F11) {
        if let Ok(mut window) = windows.single_mut() {
            window.mode = match window.mode {
                WindowMode::Windowed => {
                    println!("切换到无边框全屏模式");
                    WindowMode::BorderlessFullscreen(MonitorSelection::Current)
                },
                WindowMode::BorderlessFullscreen(_) => {
                    println!("切换到窗口模式");
                    WindowMode::Windowed
                },
                WindowMode::Fullscreen(..) => {
                    println!("从独占全屏切换到窗口模式");
                    WindowMode::Windowed
                },
            };
        }
    }
    
    if keys.just_pressed(KeyCode::Escape) {
        if let Ok(mut window) = windows.single_mut() {
            if window.mode != WindowMode::Windowed {
                println!("ESC 键退出全屏");
                window.mode = WindowMode::Windowed;
            }
        }
    }
}

fn detect_window_display_mode(
    mut window_state: ResMut<WindowState>,
    windows: Query<&Window, With<PrimaryWindow>>,
    mut resize_events: EventReader<WindowResized>,
) {
    for _event in resize_events.read() {
        if let Ok(window) = windows.single() {
            let previous_mode = window_state.display_mode;
            let window_size = Vec2::new(window.width(), window.height());
            let current_mode = WindowDisplayMode::from_window_size_and_mode(window_size, window.mode);
            
            if previous_mode != current_mode {
                window_state.display_mode = current_mode;
                window_state.resolution = window_size;
                window_state.window_mode = window.mode;
                
                println!(
                    "Window display mode changed: {:?} ({}x{}) - Window Mode: {:?}",
                    current_mode, window_size.x, window_size.y, window.mode
                );
            }
        }
    }
}

fn update_responsive_image_style(
    mut query: Query<(&mut Node, &ResponsiveImageNode)>,
    window_state: Res<WindowState>,
) {
    if !window_state.is_changed() {
        return;
    }
    
    for (mut node, responsive) in query.iter_mut() {
        let (target_style, style_name) = responsive.get_style_for_window_size(window_state.resolution);
        *node = target_style.clone();
        
        println!(
            "Updated style for {} - Mode: {:?}, Resolution: {}x{}, Style: {}",
            style_name,
            window_state.display_mode,
            window_state.resolution.x,
            window_state.resolution.y,
            match target_style.width {
                Val::Px(val) => format!("{}px", val),
                Val::Percent(val) => format!("{}%", val),
                _ => "auto".to_string(),
            }
        );
    }
}

fn update_background_size_on_resize(
    mut resize_events: EventReader<WindowResized>,
    mut sprite_query: Query<&mut Sprite>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    for _event in resize_events.read() {
        if let Ok(window) = window_query.single() {
            for mut sprite in sprite_query.iter_mut() {
                let image_aspect = 2560.0 / 1440.0;
                let window_aspect = window.width() / window.height();
                
                let (new_width, new_height) = if window_aspect > image_aspect {
                    let height = window.height();
                    let width = height * image_aspect;
                    (width, height)
                } else {
                    let width = window.width();
                    let height = width / image_aspect;
                    (width, height)
                };
                
                sprite.custom_size = Some(Vec2::new(new_width, new_height));
            }
        }
    }
}

fn typewriter_system(
    time: Res<Time>,
    mut query: Query<(&mut Text, &mut TypewriterEffect)>,
) {
    for (mut text, mut typewriter) in query.iter_mut() {
        if typewriter.finished {
            continue;
        }

        typewriter.timer.tick(time.delta());

        if typewriter.timer.just_finished() {
            if typewriter.current_index < typewriter.full_text.chars().count() {
                let chars: Vec<char> = typewriter.full_text.chars().collect();
                let current_text: String = chars[0..=typewriter.current_index].iter().collect();
                text.0 = current_text;
                typewriter.current_index += 1;
            } else {
                typewriter.finished = true;
            }
        }
    }
}
```