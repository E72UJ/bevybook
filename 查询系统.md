## 模拟CSS媒体查询系统的程序
```rust
use bevy::prelude::*;
use bevy::window::{WindowResized, WindowMode, PrimaryWindow};

// 标记组件，用于标识需要响应窗口最大化的 ImageNode
#[derive(Component)]
struct ResponsiveImageNode {
    normal_style: Node,      // 普通状态下的样式
    maximized_style: Node,   // 最大化状态下的样式
}

// 窗口状态资源
#[derive(Resource, Default)]
struct WindowState {
    is_maximized: bool,
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .insert_resource(ClearColor(Color::BLACK)) // <- 这里插入黑色背景
        .init_resource::<WindowState>()
        .add_systems(Startup, setup)
        .add_systems(Update, (
            detect_window_maximized,
            update_responsive_image_style,
            update_background_size_on_resize,
        ))
        .run();
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    // 创建2D相机
    commands.spawn(Camera2d);
    commands.spawn((
        Name::new("spritebox"),
        Transform::from_xyz(0.0, 10.0, 0.0),
        // Sprite::sized(Vec2::new(75., 75.)),
        
        Sprite {
            custom_size: Some(Vec2::new(1400.0, 770.0)),
            image: asset_server.load("background/bg6.png"),
            // custom_size: Some(Vec2 { x: 350.0, y: 540.0 }),
            ..default()
        },
        Visibility::Visible,
    ));
    // 创建响应式 ImageNode
    commands.spawn((
        ImageNode::new(asset_server.load("textbox.png")),
        Node {
            // 初始样式（普通状态）
            position_type: PositionType::Absolute,
            left: Val::Px(50.0),
            top: Val::Px(50.0),
            width: Val::Px(200.0),
            height: Val::Px(150.0),
            ..default()
        },
        ResponsiveImageNode {
            normal_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1400.0),
                height: Val::Px(270.0),
                ..default()
            },
            maximized_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(133.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1653.0),
                height: Val::Px(270.0),
                ..default()
            },
        },
    ));
    
    // 添加提示文本
    commands.spawn((
        Text::new("Window maximized detection active"),
        Node {
            position_type: PositionType::Absolute,
            top: Val::Px(10.0),
            left: Val::Px(10.0),
            ..default()
        },
        TextColor(Color::WHITE),
    ));
}

// 检测窗口最大化状态
fn detect_window_maximized(
    mut window_state: ResMut<WindowState>,
    windows: Query<&Window, With<PrimaryWindow>>,
    mut resize_events: EventReader<WindowResized>,
) {
    // 监听窗口大小变化事件
    for _event in resize_events.read() {
        if let Ok(window) = windows.single() {
            let was_maximized = window_state.is_maximized;
            
            // 检测窗口是否最大化
            let is_maximized = is_window_maximized(window);
            
            if was_maximized != is_maximized {
                window_state.is_maximized = is_maximized;
                println!("Window maximized state changed: {}", is_maximized);
            }
        }
    }
}

// 判断窗口是否最大化的辅助函数
fn is_window_maximized(window: &Window) -> bool {
    // 这是一个简化的检测方法
    let window_size = Vec2::new(window.width(), window.height());
    
    // 如果窗口尺寸大于某个阈值，认为是最大化
    window_size.x > 1200.0 && window_size.y > 800.0
}

// 更新响应式图像样式
fn update_responsive_image_style(
    mut query: Query<(&mut Node, &ResponsiveImageNode)>,
    window_state: Res<WindowState>,
) {
    // 只有当窗口状态发生变化时才更新
    if !window_state.is_changed() {
        return;
    }
    
    for (mut node, responsive) in query.iter_mut() {
        let target_style = if window_state.is_maximized {
            &responsive.maximized_style
        } else {
            &responsive.normal_style
        };
        
        // 更新节点样式
        *node = target_style.clone();
        
        println!(
            "Updated image style - maximized: {}, size: {}x{}, position: ({}, {})",
            window_state.is_maximized,
            match target_style.width {
                Val::Px(val) => val,
                _ => 0.0,
            },
            match target_style.height {
                Val::Px(val) => val,
                _ => 0.0,
            },
            match target_style.left {
                Val::Px(val) => val,
                _ => 0.0,
            },
            match target_style.top {
                Val::Px(val) => val,
                _ => 0.0,
            }
        );
    }
}

fn update_background_size_on_resize(
    mut resize_events: MessageReader<WindowResized>,
    mut sprite_query: Query<&mut Sprite>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    // 只在窗口大小改变时执行
    for _event in resize_events.read() {
        if let Ok(window) = window_query.single() {
            for mut sprite in sprite_query.iter_mut() {
                let image_aspect = 2560.0 / 1440.0; // 原图比例
                let window_aspect = window.width() / window.height(); // 窗口比例
                
                let (new_width, new_height) = if window_aspect > image_aspect {
                    // 窗口更宽，以高度为准缩放
                    let height = window.height();
                    let width = height * image_aspect;
                    (width, height)
                } else {
                    // 窗口更窄，以宽度为准缩放
                    let width = window.width();
                    let height = width / image_aspect;
                    (width, height)
                };
                
                sprite.custom_size = Some(Vec2::new(new_width, new_height));
            }
        }
    }
}
```