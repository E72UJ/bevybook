```rust
use bevy::prelude::*;
use bevy::window::{WindowResized, WindowMode, PrimaryWindow, MonitorSelection};

use bevy_text_animation::TextAnimatorPlugin;

// 打字机组件
#[derive(Component)]
pub struct TypewriterEffect {
    pub full_text: String,
    pub current_index: usize,
    pub timer: Timer,
    pub finished: bool,
}

impl TypewriterEffect {
    pub fn new(text: String, chars_per_second: f32) -> Self {
        Self {
            full_text: text,
            current_index: 0,
            timer: Timer::from_seconds(1.0 / chars_per_second, TimerMode::Repeating),
            finished: false,
        }
    }
}

// 标记组件，用于标识需要响应窗口变化的 ImageNode
#[derive(Component)]
struct ResponsiveImageNode {
    normal_style: Node,          // 普通状态下的样式
    maximized_style: Node,       // 最大化状态下的样式
    fullscreen_style: Node,      // 全屏状态下的样式
    fullscreen_1080p_style: Node, // 1920×1080 全屏专用样式
}

// 窗口状态枚举 - 添加更多分辨率支持
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum WindowDisplayMode {
    Normal,
    Maximized,
    Fullscreen,
    Fullscreen1080p,  // 专门为 1920×1080 全屏
}

// 窗口状态资源
#[derive(Resource)]
struct WindowState {
    display_mode: WindowDisplayMode,
    resolution: Vec2,
}

impl Default for WindowState {
    fn default() -> Self {
        Self {
            display_mode: WindowDisplayMode::Normal,
            resolution: Vec2::new(1400.0, 1080.0), // 默认分辨率
        }
    }
}

fn main() {
    App::new()
        .add_plugins(DefaultPlugins)
        .add_plugins(TextAnimatorPlugin)
        .insert_resource(ClearColor(Color::BLACK))
        .init_resource::<WindowState>()
        .add_systems(Startup, setup)
        .add_systems(Update, (
            toggle_fullscreen_system,
            detect_window_display_mode,
            update_responsive_image_style,
            update_background_size_on_resize,
            typewriter_system
        ))
        .run();
}

fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
    // 创建2D相机
    commands.spawn(Camera2d);
    commands.spawn((
        Name::new("spritebox"),
        Transform::from_xyz(0.0, 10.0, 0.0),
        Sprite {
            custom_size: Some(Vec2::new(1920.0, 1070.0)),
            image: asset_server.load("background/bg6.png"),
            ..default()
        },
        Visibility::Visible,
    ));
    
    commands.spawn((
        ImageNode::new(asset_server.load("textbox.png")),
        Node {
            // 初始样式（普通状态）
            position_type: PositionType::Absolute,
            left: Val::Px(50.0),
            top: Val::Px(50.0),
            width: Val::Px(200.0),
            height: Val::Px(150.0),
            ..default()
        },
        ResponsiveImageNode {
            normal_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1400.0),
                height: Val::Px(270.0),
                ..default()
            },
            maximized_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(133.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1653.0),
                height: Val::Px(270.0),
                ..default()
            },
            fullscreen_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Percent(100.0),
                height: Val::Px(300.0),
                ..default()
            },
            // 专门为 1920×1080 优化的样式
            fullscreen_1080p_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                bottom: Val::Px(0.0),
                width: Val::Px(1920.0),  // 精确匹配 1920 宽度
                height: Val::Px(280.0),  // 为 1080p 优化的高度
                ..default()
            },
        },
    ));

    // 创建响应式 ImageNode
    commands.spawn((
        ImageNode::new(asset_server.load("sidebar/456.png")),
        ZIndex(1),
        Node {
            // 初始样式（普通状态）
            position_type: PositionType::Absolute,
            left: Val::Px(0.0),
            top: Val::Px(0.0),
            width: Val::Px(960.0),
            height: Val::Px(1080.0),
            ..default()
        },
        ResponsiveImageNode {
            normal_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(960.0),
                height: Val::Px(1080.0),
                ..default()
            },
            maximized_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(500.0),
                height: Val::Px(1080.0),
                ..default()
            },
            fullscreen_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(960.0),
                height: Val::Px(1080.0),
                ..default()
            },
            // 1920×1080 专用样式 - 可能需要不同的侧边栏尺寸
            fullscreen_1080p_style: Node {
                position_type: PositionType::Absolute,
                left: Val::Px(0.0),
                top: Val::Px(0.0),
                width: Val::Px(960.0),   // 保持原尺寸或调整
                height: Val::Px(1080.0), // 精确匹配 1080 高度
                ..default()
            },
        },
    ));
    
    // 添加提示文本
    commands.spawn((
        Text::new("你好，秋月寒"),
        TextFont {
            font: asset_server.load("two.ttf"),
            font_size: 27.0,
            ..default()
        },
        Node {
            position_type: PositionType::Absolute,
            left: Val::Px(590.0),
            bottom: Val::Px(220.0),
            margin: UiRect::all(Val::Px(1.0)),
            ..default()
        },
        ZIndex(2),
        TextColor(Color::srgb_u8(0xb6, 0xf6, 0xfe)),
        Transform::from_xyz(409.0, 200.0, 0.0),
        TypewriterEffect::new("你好，秋月寒".to_string(), 15.0),
    ));
}

fn toggle_fullscreen_system(
    mut windows: Query<&mut Window, With<PrimaryWindow>>,
    keys: Res<ButtonInput<KeyCode>>,
) {
    if keys.just_pressed(KeyCode::F11) {
        if let Ok(mut window) = windows.single_mut() {
            window.mode = match window.mode {
                WindowMode::Windowed => {
                    println!("切换到无边框全屏模式");
                    WindowMode::BorderlessFullscreen(MonitorSelection::Current)
                },
                WindowMode::BorderlessFullscreen(_) => {
                    println!("切换到窗口模式");
                    WindowMode::Windowed
                },
                WindowMode::Fullscreen(..) => {
                    println!("从独占全屏切换到窗口模式");
                    WindowMode::Windowed
                },
            };
        }
    }
    
    if keys.just_pressed(KeyCode::Escape) {
        if let Ok(mut window) = windows.single_mut() {
            if window.mode != WindowMode::Windowed {
                println!("ESC 键退出全屏");
                window.mode = WindowMode::Windowed;
            }
        }
    }
}

// 增强的窗口检测系统
fn detect_window_display_mode(
    mut window_state: ResMut<WindowState>,
    windows: Query<&Window, With<PrimaryWindow>>,
    mut resize_events: MessageReader<WindowResized>,
) {
    for _event in resize_events.read() {
        if let Ok(window) = windows.single() {
            let previous_mode = window_state.display_mode;
            let window_size = Vec2::new(window.width(), window.height());
            let current_mode = determine_window_display_mode_with_resolution(window, window_size);
            
            if previous_mode != current_mode {
                window_state.display_mode = current_mode;
                window_state.resolution = window_size;
                println!("Window display mode changed: {:?} ({}x{})", 
                    current_mode, window_size.x, window_size.y);
            }
        }
    }
}

// 精确的分辨率检测函数
fn determine_window_display_mode_with_resolution(window: &Window, window_size: Vec2) -> WindowDisplayMode {
    // 首先检查明确的全屏模式
    match window.mode {
        WindowMode::Fullscreen(..) | WindowMode::BorderlessFullscreen(_) => {
            // 检查是否是 1920×1080 全屏
            if is_resolution_match(window_size, Vec2::new(1920.0, 1080.0), 10.0) {
                return WindowDisplayMode::Fullscreen1080p;
            } else {
                return WindowDisplayMode::Fullscreen;
            }
        }
        _ => {}
    }
    
    // 检查其他可能的全屏状态（程序化全屏）
    if is_resolution_match(window_size, Vec2::new(1920.0, 1080.0), 10.0) {
        return WindowDisplayMode::Fullscreen1080p;
    }
    
    // 检查是否可能是其他分辨率的全屏
    if is_likely_fullscreen(window_size) {
        WindowDisplayMode::Fullscreen
    } else if is_window_maximized(window_size) {
        WindowDisplayMode::Maximized
    } else {
        WindowDisplayMode::Normal
    }
}

// 精确的分辨率匹配函数
fn is_resolution_match(actual: Vec2, target: Vec2, tolerance: f32) -> bool {
    let width_diff = (actual.x - target.x).abs();
    let height_diff = (actual.y - target.y).abs();
    width_diff <= tolerance && height_diff <= tolerance
}

// 预定义常见分辨率的媒体查询
fn get_resolution_breakpoints() -> Vec<(Vec2, &'static str)> {
    vec![
        (Vec2::new(1920.0, 1080.0), "1080p"),
        (Vec2::new(2560.0, 1440.0), "1440p"),
        (Vec2::new(3840.0, 2160.0), "4K"),
        (Vec2::new(1366.0, 768.0), "768p"),
        (Vec2::new(1600.0, 900.0), "900p"),
        (Vec2::new(2560.0, 1600.0), "MacBook Pro 13"),
        (Vec2::new(3008.0, 1692.0), "MacBook Pro 16"),
        (Vec2::new(3440.0, 1440.0), "Ultrawide"),
    ]
}

// 检测具体分辨率
fn detect_specific_resolution(window_size: Vec2) -> Option<&'static str> {
    let breakpoints = get_resolution_breakpoints();
    
    for (resolution, name) in breakpoints {
        if is_resolution_match(window_size, resolution, 20.0) {
            return Some(name);
        }
    }
    None
}

fn is_likely_fullscreen(window_size: Vec2) -> bool {
    // 检查是否匹配任何已知的全屏分辨率
    let breakpoints = get_resolution_breakpoints();
    
    for (resolution, _) in breakpoints {
        if is_resolution_match(window_size, resolution, 50.0) {
            return true;
        }
    }
    
    // 如果没有精确匹配，使用原来的逻辑
    let aspect_ratio = window_size.x / window_size.y;
    let is_common_aspect = 
        (aspect_ratio - 16.0/9.0).abs() < 0.1 ||
        (aspect_ratio - 16.0/10.0).abs() < 0.1 ||
        (aspect_ratio - 21.0/9.0).abs() < 0.1 ||
        (aspect_ratio - 4.0/3.0).abs() < 0.1 ||
        (aspect_ratio - 3.0/2.0).abs() < 0.1;
    
    let is_large_enough = window_size.x >= 1024.0 && window_size.y >= 600.0;
    let is_very_large = window_size.x >= 1800.0 || window_size.y >= 1000.0;
    
    is_common_aspect && is_large_enough && is_very_large
}

fn is_window_maximized(window_size: Vec2) -> bool {
    let is_reasonably_large = window_size.x > 1000.0 && window_size.y > 600.0;
    let is_not_fullscreen = !is_likely_fullscreen(window_size);
    let could_be_maximized = window_size.x > 1200.0 && window_size.y > 700.0;
    
    is_reasonably_large && is_not_fullscreen && could_be_maximized
}

// 增强的响应式样式更新
fn update_responsive_image_style(
    mut query: Query<(&mut Node, &ResponsiveImageNode)>,
    window_state: Res<WindowState>,
) {
    if !window_state.is_changed() {
        return;
    }
    
    for (mut node, responsive) in query.iter_mut() {
        let target_style = match window_state.display_mode {
            WindowDisplayMode::Normal => &responsive.normal_style,
            WindowDisplayMode::Maximized => &responsive.maximized_style,
            WindowDisplayMode::Fullscreen => &responsive.fullscreen_style,
            WindowDisplayMode::Fullscreen1080p => &responsive.fullscreen_1080p_style, // 专用样式
        };
        
        *node = target_style.clone();
        
        // 输出更详细的信息
        if let Some(resolution_name) = detect_specific_resolution(window_state.resolution) {
            println!(
                "Updated image style - mode: {:?} ({}), resolution: {}x{}, size: {}x{}, position: ({}, {})",
                window_state.display_mode,
                resolution_name,
                window_state.resolution.x,
                window_state.resolution.y,
                match target_style.width {
                    Val::Px(val) => format!("{}px", val),
                    Val::Percent(val) => format!("{}%", val),
                    _ => "auto".to_string(),
                },
                match target_style.height {
                    Val::Px(val) => format!("{}px", val),
                    Val::Percent(val) => format!("{}%", val),
                    _ => "auto".to_string(),
                },
                match target_style.left {
                    Val::Px(val) => val,
                    _ => 0.0,
                },
                match target_style.top {
                    Val::Px(val) => val,
                    _ => 0.0,
                }
            );
        }
    }
}

fn update_background_size_on_resize(
    mut resize_events: MessageReader<WindowResized>,
    mut sprite_query: Query<&mut Sprite>,
    window_query: Query<&Window, With<PrimaryWindow>>,
) {
    for _event in resize_events.read() {
        if let Ok(window) = window_query.single() {
            for mut sprite in sprite_query.iter_mut() {
                let image_aspect = 2560.0 / 1440.0;
                let window_aspect = window.width() / window.height();
                
                let (new_width, new_height) = if window_aspect > image_aspect {
                    let height = window.height();
                    let width = height * image_aspect;
                    (width, height)
                } else {
                    let width = window.width();
                    let height = width / image_aspect;
                    (width, height)
                };
                
                sprite.custom_size = Some(Vec2::new(new_width, new_height));
            }
        }
    }
}

fn typewriter_system(
    time: Res<Time>,
    mut query: Query<(&mut Text, &mut TypewriterEffect)>,
) {
    for (mut text, mut typewriter) in query.iter_mut() {
        if typewriter.finished {
            continue;
        }

        typewriter.timer.tick(time.delta());

        if typewriter.timer.just_finished() {
            if typewriter.current_index < typewriter.full_text.chars().count() {
                let chars: Vec<char> = typewriter.full_text.chars().collect();
                let current_text: String = chars[0..=typewriter.current_index].iter().collect();
                text.0 = current_text;
                typewriter.current_index += 1;
            } else {
                typewriter.finished = true;
            }
        }
    }
}
```